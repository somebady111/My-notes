# My Notes

`Day:`2020-9-20 Sunday

`Title:`

1. kali更新命令
2. 收集3.6版本库名迁移3.8
3. Windows中添加环境变量
4. Linux系统安装python版本

`Content:`

```python
# kali更新命令
nano /etc/apt/sources.list
apt-get update && apt-get dist-upgrade -y

# 虚拟环境搭建(python3.7环境venv)
sudo apt-get install python3-venv
python3.7 -m venv xxx-env
cd typeidea-env
source bin/activate
pip3 install xxx
deactivate

# Linux常用命令
https://www.runoob.com/linux/linux-command-manual.html
    
# Linux系统中安装python版本
1.安装基础库
sudo apt-get install -y python3-dev build-essential libssl-dev libffi-dev libxml2 libxml2-dev libxslt1-dev zlib1g-dev libcurl4-openssl-dev
2.sudo apt-get install -y python3  (2020-9-20 实测python版本3.8.2)
3.安装pip3
sudo apt-get install -y python3-pip

# win系统添加环境变量
1.sysdm.cpl # 进入环境变量设置
2.path目录
3.添加目标目录
4.比如安装（2020-9-20）Python3.8.2版本，添加环境变量后正常调用为python3.8.2
```

`Day:`2020-10-1 Thursday

`Title:`

1.专四词汇

2.UDP和TCP编写，及详情总结

`Content:`

```python
# 1.专四词汇
heartbreaking adj.悲伤或失望到难以承受忍受的程度；令人悲伤的 v.使...心碎
disintegrate n.解体，瓦解，崩溃；破碎，分裂，粉碎
sympathetic adj.有同情心的；同情的；支持的
mystery n.神秘的事物；神秘感
interfere v.干涉，妨碍

# 2.UDP

#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# python version:python3.8
# author:jingzuo
# python3 udp

import socket,argparse
from datetime import datetime

MAX_BYTES = 65535

def server(port):
    # 创建套接字
    sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    # 绑定IP，端口
    sock.bind(('127.0.0.1',port))
    # 获取打印套接字的名字
    print('Listening at {}'.format(sock.getsockname()))
    while True:
        # 接收客户端发送的内容
        data,address = sock.recvfrom(MAX_BYTES)
        # 对内容进行解码
        text = data.decode('ascii')
        print('The Client at {} says {!r}'.format(address,text))
        text = 'your data was {} bytes long'.format(len(data))
        # 编码发送内容长度，地址
        data = text.encode('ascii')
        sock.sendto(data,address)

def client(port):
    sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    text = 'The time is {}'.format(datetime.now())
    data = text.encode('ascii')
    sock.sendto(data,('127.0.0.1',port))
    print('The Os assigned me the address {}'.format(sock.getsockname()))
    data,address = sock.recvfrom(MAX_BYTES)
    text = data.decode('ascii')
    print('The sever {} replied {!r}'.format(address,text))

if __name__ == "__main__":
    # argparse函数
    # 创建argparse函数选项(参数)
    choices = {'client':client,'server':server}
    # 参数描述
    parser = argparse.ArgumentParser(description='Send and receive udp locally')
    parser.add_argument('role',choices=choices,help='which role to play')
    parser.add_argument('-p',metavar='PORT',type=int,default=1060,help='udp port default 1060')
    args = parser.parse_args()
    function = choices[args.role]
    function(args.p)

# 3.tcp

```





`Day:`2020-10-12 PM19:46

`1.收支统计`

取钱：单支出5元，充饭卡300元，13号充值

补衣服：12元

零食：3元

购物：373.15元

`2.10月11日学习内容回顾`

1.原始的名称服务程序

```python
import socket
# 获取主机名称
s = socket.gethostname()
print('hostname is {}'.format(s))

sockname = socket.getfqdn()
print('sockname is {}'.format(sockname))

# 对IPV4主机名和IP地址相互转换
ip = socket.gethostbyname('LAPTOP-DIALKSAK')
# 此处查明的ip为以太网的IP地址
print('The host IP is {}'.format(ip))

address = socket.gethostbyaddr(ip)
print('The host addr is {}'.format(address))

#查询操作系统已知的符号名查询协议号和端口号
port1 = socket.getprotobyname('UDP')
port2 = socket.getservbyname('onion')
name = socket.getservbyport(port1)

# 获取运行python程序的机器主IP地址
pro_ip = socket.gethostbyname(socket.getfqdn())
print('the pro_ip is {}'.format(pro_ip))
```

2.getaddrinfo()使用场景

只在主机名查询	时大量使用，真正创建客户端、服务端需要tcp，udp此类协议的方法。

3.DNS协议

DNS是域名解析系统的简称，是对主机名和IP地址的映射的一种机制。

whois 获取服务器中存储的相关域名的信息。

```python
whois python.org
```



4.使用python进行DNS查询

```python
pip install dnspython3

import argparse,dns.resolver

def lookup(name):
    for qtype in 'A','AAAA','CNAME','MX','NS':
        answer = dns.resolver.query(name,qtype,raise_on_answer=False)
        if answer.rrset is not None:
            print(answer.rrset)
            
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='...')
    parser.add_argument('name',help='...')
    lookup(parser.parse_args().name)
    
```

类型：

A 代表IPV4

AAAA 代表IPV6

NS 名称服务器

MX 邮件服务器

CNAME 别名



#### Day:2020-10-14

`十月十三号回顾`

`1.二进制数和字节顺序`

大端法：将高位字节存储在前面

小端法：将低位字节存储在前面

```python
import struct

# 大端法
struct.pack('<i',4253)
# 小端法
struct.pack('>i',4253)

# 转换二进制数字
struct.unpack('<i',b'\x8d\x10\x00\x00')
```

`2.封帧和引用`

封帧要考虑的问题:

1.接收方何时最终停止调用recv（）才最安全？

2.整个消息或数据何时才能完整的传达？

3.何时才能将接收到的消息作为一个整体来处理？

模式一：用于一些简单的网络协议

发送方循环发送数据，直到所有数据都传递给sendall（）为止，然后close（）关闭套接字；接收方只需要不断调用recv（），直到recv（）最后返回一个空字符串为止。	

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# author: jingzuo
# 封帧的模式一

import socket,argparse

def server(address):
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    sock.bind(address)
    sock.listen(1)
    print('Run this script in another window with "-c" to connect')
    print('listening at {}'.format(sock.getsockname()))
    sc,sockname = sock.accept()
    print('accepted connection from {}'.format(sockname))
    sc.shutdown(socket.SHUT_WR)
    message = b''
    while True:
        more = sc.recv(8192)
        if not more:
            print('Received zero bytes - end of file')
            break
        print('Received {} bytes'.format(len(more)))
        message += more
    print('Message:\n')
    print(message.decode('ascii'))
    sc.close()
    sock.close()

def client(address):
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect(address)
    sock.shutdown(socket.SHUT_RD)
    sock.sendall(b'beautiful is better than ugly.\n')
    sock.sendall(b'explicit is better than implicit.\n')
    sock.sendall(b'simple is better than complex.\n')
    sock.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='transmit & receive a data stream')
    parser.add_argument('hostname',nargs='?',default='127.0.0.1')
    parser.add_argument('-c',action='store_true',help='run as the client')
    parser.add_argument('-p',type=int,metavar='port',default=1060,help='Tcp port number (default:%(default)s)')
    args = parser.parse_args()
    function = client if args.c else server
    function((args.hostname,args.p))

```



模式二：在两个方向上都通过流发送消息。

首先，通过流在一个方向上发送信息，然后关闭此方向；然后，在另一个方向上通过流发送数据，最后关闭套接字。

模式三：使用定长消息。

eg：发送16bit长度消息，另一端在接收到16bit长度消息后，确认接收完毕，关闭套接字连接。

模式四：使用特殊字符来划分消息边界。

接收方进入recv（）循环并不断等待，知道累加到返回字符串包含消息结束的定界符为止。

只有在消息使用字母表有限时，才使用定界符机制。

模式五：在每个消息加上其长度作为前缀。

类似于定长消息收发

模式六：发送多个数据块，并在每个数据块前加上数据块长度作为其前缀。

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# author:jingzuo
# block data stream

import socket,argparse,struct

# 设置4bit长度的定界符
header_struct = struct.Struct('!I')

def recvall(sock,length):
    blocks = []
    while length:
        block = sock.recv(length)
        if not block:
            raise EOFError('socket closed with {} bytes left in this block'.format(length))
        length -= len(block)
        blocks.append(block)
    return b''.join(blocks)

def get_block(sock):
    data = recvall(sock,header_struct.size)
    (block_length,) = header_struct.unpack(data)
    return recvall(sock,block_length)

def put_block(sock,message):
    block_length = len(message)
    sock.send(header_struct.pack(block_length))
    sock.send(message)

def server(address):
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    sock.bind(address)
    sock.listen(1)
    print('Run this script in anthor window with "-c" to connect')
    print('listening at {}'.format(sock.getsockname()))
    sc,sockname = sock.accept()
    print('accepted connection from {}'.format(sockname))
    sc.shutdown(socket.SHUT_WR)
    while True:
        # 将流打包处理
        block = get_block(sc)
        if not block:
            break
        print('block says {}'.format(repr(block)))
    sc.close()
    sock.close()

def client(address):
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect(address)
    sock.shutdown(socket.SHUT_RD)
    # 为消息添加长度前缀
    put_block(sock,b'Beautiful is better than ugly')
    put_block(sock,b'Explicit is better than implict')
    put_block(sock,b'simple is better than complex')
    put_block(sock,b'')
    sock.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Transmit & reveive blocks over ICP')
    parser.add_argument('hostname',nargs='?',default='127.0.0.1',help='ip address or hostname (default:%(default)s)')
    parser.add_argument('-c',action='store_true',help='run as the client')
    parser.add_argument('-p',type=int,metavar='port',default=1060,help='tcp port number (default:%(default)s)')
    args = parser.parse_args()
    function = client if args.c else server
    function((args.hostname,args.p))
    
```



#### Day:2020-10-16

`1.pickle与自定义定界符的格式`

```python
import pickle
from io import BytesIO

# pickle原生序列化
list = pickle.dumps([5,6,7])
print('the binary type an {}'.format(list))
protogenesis = pickle.loads(list)
print('the proto_data is {}'.format(protogenesis))

# 文件读取pickle数据
f = BytesIO(list)
file_list = pickle.load(f)
print('file read content is {}'.format(file_list))
len_list = f.tell()
print('the byte_list length is {} data'.format(len_list))
behind_data = f.read()
print('behind data is {}'.format(behind_data)) # 读取分解符.后的数据内容

```

`2.压缩（zlib）`

```python
import zlib

data = zlib.compress(b'python') + b'.' + zlib.compress(b'zlib') + b'.'
print(data)
length_data = len(data)
print(length_data)

d = zlib.decompressobj()
d.decompress(data[0:len(data)])
# unused_data 解压缩对象d的unused_data槽
d.unused_data
```

`3.异常`

```python
OSError socket模块的主要错误
socket.gaierror 在getaddrinfo（）无法找到提供的名称或服务器时
socket.timeout 超时错误
scoket.error 打印具体错误


# 错误收集
# 捕捉异常报告blanket
import sys

try:
    pass
except (socket.error,scoket.gaierror) as e:
    print('find error {} in this file'.format(e),file=sys.stderr)
    exit(1)
```

#### Day:2020-10-20 

`1.什么是TLS？以及TLS无法保护哪些信息？`

1.什么是TLS？

TLS,传输安全层协议（Transport Layer Security）

2.TLS无法保护那些信息？

a.本机和远程主机的地址

b.客户端与服务器的端口号

c.客户端获取服务器的IP地址会进行不可保护的DNS查询



`2.建立一个简单的通过TLS套接字进行通信的客户端和服务端`

```python
# 为套接字连接提供一个安全通信的步骤
# step1:创建一个TLS上下文
context = ssl.create_default_context()
# step2:调用上下文对象的wrap_socket()方法，建立加密通信
ssl_sock = context.wrap_socket()
# step3:通过返回对象ssl_sock进行后续通信内容

#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# author: jingzuo
# content:a simple client and server through tls socket to security communication

import socket,ssl,argparse

def client(host,port,cafile=None):
    # 确认ssl连接的目标
    purpose = ssl.Purpose.SERVER_AUTH
    context = ssl.create_default_context(purpose,cafile=cafile)

    raw_sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    raw_sock.connect((host,port))
    print('the connection address is {!r} port is {}'.format(host,port))
    # 调用对象context的wrap_socket()方法，让OPenSSL库负责控制TCP连接，与通信双方进行必要的握手协议，并建立加密连接
    ssl_sock = context.wrap_socket(raw_sock,server_hostname=host)
    while True:
        data = ssl_sock.recv(1024)
        if not data:
            break
        print(repr(data))

def server(host,port,certfile,cafile=None):
    purpose = ssl.Purpose.CLIENT_AUTH
    # 创建一个TLS上下文对象context，保存对证书和加密算法的偏好设置
    context = ssl.create_default_context(purpose,cafile=cafile)
    context.load_cert_chain(certfile)

    listener = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    listener.getsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    listener.bind((host,port))
    listener.listen(1)
    print('listening at interface {!r} and port {}'.format(host,port))
    raw_sock,address = listener.accept()
    print('connection from host {!r} and port {}'.format(*address))
    # 调用对象context的wrap_socket()方法，让OPenSSL库负责控制TCP连接，与通信双方进行必要的握手协议，并建立加密连接
    ssl_sock = context.wrap_socket(raw_sock,server_side=True)
    # 使用wrap_socket()调用返回的ssl_sock对象，进行后续通信
    ssl_sock.sendall('simple is better than complex'.encode('ascii'))
    ssl_sock.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='this is client and server to safe tls communication')
    parser.add_argument('host',help='hostname or IP address')
    parser.add_argument('port',type=int,help='Tcp port number')
    parser.add_argument('-a',metavar='cafile',default=None,help='path to ca certificate pem file')
    parser.add_argument('-s',metavar='certfile',default=None,help='run as server')
    args = parser.parse_args()
    if args.s:
        server(args.host,args.port,args.s,args.a)
    else:
        client(args.host,args.port,args.a)

```

```reStructuredText
# 参数说明
1.cafile选项：表示脚本验证远程地址是信任的证书机构
证书在验证时，会选用知名的公共证书或是本地保存的整数，同时使用两种证书的设置需要设置以下：
a.设置上下文
>>>context = ssl.creat_default_context()
b.设置cafile为None
c.调用方法安装其他证书
>>>context.load_verify_locations(cafile)

2.wrap_socket()选项
wrap_socket()选项一个使用在客户端，一个使用在服务端。
服务端使用参数：
>>>server_side = True
客户端使用参数（在已提供到connect的主机地址后）:
>>>server_hostname=host
```

------



#### Day:2020-10-26 周一

`1.TLS（安全完美前向安全）`

对数据保密要求较高，需要制定OpenSSL使用确切的加密算法。

```python
# 设置特定的协议版本或加密算法
# ciphers 返回OpenSSL与通信对方连接中使用的加密算法
context = ssl.SSL.Context(ssl.PROTOCOL_TLSv1_2)
context.verify_mode = ssl.CERT_MODE
context.options |= ssl.OP_CIPHER_SERVER_PREFERENCE
...
context.set_ciphers('ECDH+AES128') # ECDHE椭圆曲线加密算法
```

`2.支持TLS的协议`

如何配置加密算法和选项。

a.http.client  构造一个HTTPConnection对象

b.smtplib  构造一个SMTP_SSL对象

c.poplib  构造一个POP3_SSL对象

d.imaplib  构造一个IPV4_SSl对象

e.ftplib  构造一个FTP_TLS对象

f.nntplib  构造一个NNTP网络新闻对象

------



#### Day:2020-10-27 周二

`1，章节7：服务器架构`

网络服务面临的挑战：

1.正确处理请求并构造合适的响应代码

2.如何将网络代码部署到随系统自动启动的windows服务器或是Unix守护进程中，将活动日志持久化存储，并在无法连接到数据库或后端数据存储区时发出警告，为其提供完整的保护，防止所有失败的情形，或是确保在失败时快速重启。

解决方案：

1.使用多个线程或进程和

2.使用异步网络操作来支持多路复用，不直接使用操作系统提供的多路复用。

------

`2.部署`

要使用单台机器上的服务，客户端只要直接连接到该机器的IP地址即可；而要使用运行在多台机器上的服务，就需要更复杂的方法。

1.一种法案是将该服务的某个实例的地址或主机名返回给客户端，但是服务的时立即塔基，通过主机名或IP地址硬编码连接该服务的客户端都无法继续连接。

2.健壮的方法：令DNS服务器返回运行该服务的所有IP地址，客户端在连接第一个地址不成功的情况下，会去尝试第二第三个地址的连接。广泛使用的方法是在服务前端配置一个负载均衡器，客户端会连接到负载均衡器，由负载均衡器将连接请求转发至实际的服务器。

大型的互联网机房都配置了一个负载均衡器和服务器群，公共的DNS名会返回用户距离最近的机房中的负载均衡器的IP地址。

supervisord

该工具可以运行程序的一个或多个副本，将标准输出流和标准错误流输出到日志文件，并且在进程发生故障时重启进城难。在服务故障过于频繁是发送警告通知。

------

`3.协议实例`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# author : jingzuo
# content:一个基于tcp协议构建的多服务端一个客户端模型

import argparse,socket,time

# message
aphorisms = {
    b'Beautiful is better than?' : b'Ugly.',
    b'Explicit is better than?' : b'Implict.',
    b'Simple is better than?' : b'Complex.'
}

def get_answer(aphorism):
    '''
    快速查找
    :return:
    '''
    time.sleep(0.0)
    return aphorisms.get(aphorism,b'Error:Unknow aphorisms')

def parse_command_line(description):
    '''
    获取命令行输入内容
    :return:socker address
    '''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('host',help='IP or hostname')
    parser.add_argument('-p',metavar='port',type=int,default=1060,help='tcp port default 1060')
    args = parser.parse_args()
    address = (args.host,args.p)
    return address

def create_srv_socket(address):
    '''
    构造tcp连接套接字函数
    :return: tcp套接字对象
    '''
    listener = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    listener.getsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    listener.bind(address)
    # 决定为服务端的关键函数listen()
    listener.listen(64)
    print('Listening at {}'.format(address))
    return listener

def accept_conversation_forever(listener):
    '''
    不断接收连接的函数
    :return:
    '''
    while True:
        sock,address = listener.accept()
        print('accepted connection from {}'.format(address))
        handle_conversation(sock,address)

def handle_conversation(sock,address):
    '''
    处理连接异常函数
    :return:
    '''
    try:
        while True:
            handle_request(sock)
    except EOFError:
        print('Client socket to {} has closed'.format(address))
    except Exception as e:
        print('Client {} error:{}'.format(address,e))
    finally:
        sock.close()

def handle_request(sock):
    '''
    处理收发消息并进行封帧
    消息封帧
    :return:
    '''
    aphorism = recv_until(sock,b'?')
    answer = get_answer(aphorism)
    sock.sendall(answer)

def recv_until(sock,suffix):
    '''
    处理消息接收
    :return:
    '''
    message = sock.recv(4096)
    if not message:
        raise EOFError('Socket closed')
    while not message.endswith(suffix):
        data = sock.recv(4096)
        if not data:
            raise IOError('received {!r} then socket closed'.format(message))
        message += data
    return message

```



```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# author : jingzuo
# content : a Example client

import argparse,random,socket
import zen_utils

def client(address,cause_error=False):
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect(address)
    aphorisms = list(zen_utils.aphorisms)
    if cause_error:
        sock.sendall(aphorisms[0][:-1])
        return
    for aphorism in random.sample(aphorisms,3):
        sock.sendall(aphorism)
        print(aphorism,zen_utils.recv_until(sock,b'.'))
    sock.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Example client')
    parser.add_argument('host',help='ip or address')
    # cause_error 正常为False，当发送不完整的消息时，服务器挂起
    parser.add_argument('-e',action='store_true',help='cause an error')
    parser.add_argument('-p',metavar='port',type=int,default=1060,help='tcp port default 1060')
    args = parser.parse_args()
    address = (args.host,args.p)
    client(address,args.e)
```

```bash
>>>python client.py 127.0.0.1
```





####  Day：2020-10-28 周三

`1.单词例句`

```reStructuredText
presently adv.一会儿，不久，目前，马上
eg：Don't worry,The doctors will be here presently. 别担心，医生马上就到。

brood n.一窝，同窝幼崽 v.冥思苦想；默想
eg：The brood of young birds. 一窝小鸟。

diplomacy n.外交；外交手腕
eg：Diplomacy is an import method of solving probloms.外交是问题的方法。

repetition n.重复，反复

solitary adj.单独的，隐居的
eg：a solitary man.

doctrine n.教条，学说，信条，原则

scapegoat n.替罪羊
```



`2.单线程服务器`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# name:srv_single
# author：jingzuo
# content：单线程服务器,one client at a time other must wait
# environment：Ubuntu linux run.

import zen_utils

if __name__ == "__main__":
    address = zen_utils.parse_command_line('simple single-threaded server')
    listener = zen_utils.create_srv_socket(address)
    zen_utils.accept_conversation_forever(listener)
```

```bash
# 使用标准库的trace模块运行单线程服务器，测试每一行代码花费的时间
python3.7 -m trace -tg --ignore-dir=/usr srv_single.py

结果如下：
 --- modulename: srv_single, funcname: <module>
0.00 srv_single.py(6): import zen_utils
 --- modulename: zen_utils, funcname: <module>
0.00 zen_utils.py(6): import argparse,socket,time
0.02 zen_utils.py(10):     b'Beautiful is better than?' : b'Ugly.',
0.02 zen_utils.py(11):     b'Explicit is better than?' : b'Implict.',
0.02 zen_utils.py(12):     b'Simple is better than?' : b'Complex.'
0.02 zen_utils.py(15): def get_answer(aphorisms):
0.02 zen_utils.py(23): def parse_command_line(description):
0.02 zen_utils.py(35): def create_srv_socket(address):
0.02 zen_utils.py(48): def accept_conversation_forever(listener):
0.02 zen_utils.py(58): def handle_conversation(sock,address):
0.02 zen_utils.py(73): def handle_request(sock):
0.02 zen_utils.py(83): def recv_until(sock,suffix):
0.02 srv_single.py(8): if __name__ == "__main__":
0.02 srv_single.py(9):     address = zen_utils.parse_command_line('simple single-threaded server')
 --- modulename: zen_utils, funcname: parse_command_line
0.02 zen_utils.py(28):     parser = argparse.ArgumentParser(description=description)
0.02 zen_utils.py(29):     parser.add_argument('host',help='IP or hostname')
0.02 zen_utils.py(30):     parser.add_argument('-p',metavar='port',type=int,default=1060,help='tcp port default 1060')
0.02 zen_utils.py(31):     args = parser.parse_args()
usage: srv_single.py [-h] [-p port] host
srv_single.py: error: the following arguments are required: host

```

`3.多线程服务器`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# name:srv_threaded
# author:jingzuo
# content:using multiple threads to server clients in parallel
# environment:ubuntu linux 

import zen_utils
from threading import Thread

def start_threads(listener,workers=4):
    t= (listener,)
    for i in range(workers):
        Thread(target=zen_utils.accept_conversation_forever,args=t).start()

if __name__ == "__main__":
    address = zen_utils.parse_command_line('multi-thread server')
    listener = zen_utils.create_srv_socket(address)
    start_threads(listener)
```

`4.异步服务器`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# name:srv_async
# author:jingzuo
# environment:Ubuntu Linux
# content:a example of asynchronous I/O driven directly by the poll() system call.

import select
from .. import zen_utils

def all_events_forever(poll_object):
    '''
    一层：poll（）的while循环，返回多个事件
    二层：for 循环处理每一个事件
    :return: 迭代器（yield）对象，当前遍历事件
    '''
    while True:
        for fd,event in poll_object.poll():
            # 将遍历的值隐藏在yield中，避免主服务器循环因为两次循环迭代产生两次不必要的缩进
            yield fd,event

def server(listener):
    '''

    :param listener:
    :return:
    '''
    # 创建socket字典
    sockets = {listener.fileno():listener}
    addresses = {}
    bytes_received = {}
    bytes_to_send = {}

    # 创建poll对象
    poll_object = select.poll()
    # 通过register告知poll对象，已经准备好从新返回的客户端接收套接字数据
    poll_object.register(listener,select.POLLIN)
    # 接收yield返回的值,添加在消息队列中
    for fd,event in all_events_forever(poll_object):
        sock = sockets[fd]
        if event & (select.POLLHUP | select.POLLERR | select.POLLNVAL):
            address = addresses.pop(sock)
            # 接收池
            rb = bytes_received.pop(sock,b'')
            # 发送池
            sb = bytes_to_send.pop(sock,b'')
            if rb:
                print('client {} send {} but then closed.'.format(address,rb))
            elif sb:
                print('client {} closed before we sent {}'.format(address,sb))
            else:
                print('client {} closed socket normally'.format(address))

            poll_object.unregister(fd)
            del sockets[fd]

        # 当套接字本身就是客户端的套接字，事件类型为POLLIN，能够给使用recv（）方法接收数据。切换POLLIN模式何POLLOUT模式
        elif sock is listener:
            sock,address = sock.accept()
            print('accepted connection from {}'.format(address))
            # 将所有新客户端套接字的设置为非阻塞模式
            sock.setblocking(False)
            sockets[sock.fileno()] = sock
            addresses[sock] = address
            poll_object.register(sock,select.POLLIN)

        # 如果套接字是PULLOUT模式，只要客户端套接字的发送缓冲区还能接收一个或多个字节，poll调用就会提醒，send（）会发送余下内容，发送内容超出缓存区将保存至bytes_to_send
        elif event & select.POLLIN:
            more_data = sock.recv(4096)
            if not more_data:
                sock.close()
                continue
            data = bytes_received.pop(sock,b'') + more_data
            if data.endswith(b'?'):
                bytes_to_send[sock] = zen_utils.get_answer(data)
                poll_object.modify(sock,select.POLLOUT)
            else:
                bytes_received[sock] = data

        # 如果客户端套接字返回了错误信息或是关闭状态，该客户端套接字及其发送缓冲区与接收缓冲区将被丢弃。
        elif event & select.POLLOUT:
            data = bytes_to_send.pop(sock)
            n = sock.send(data)
            if n < len(data):
                bytes_to_send[sock] = data[n:]
            else:
                poll_object.modify(sock,select.POLLIN)

if __name__ == "__main__":
    address = zen_utils.parse_command_line('low-level async server')
    listener = zen_utils.create_srv_socket(address)
    server(listener)
```



#### Day：2020-10-30 周五

`1.回调风格的asyncio`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# environment:Ubuntu linux
# author : jingzuo
# content: Asynchronous I/O inside asyncio callback methods

import asyncio
import zen_utils

class Zenserver(asyncio.Protocol):

    def connetction_made(self,transport):
        self.transport = transport
        self.address = transport.get_extra_info('peername')
        self.data = b''
        print('accepted connection from {}'.format(self.address))

    def connection_lost(self, exc):
        if exc:
            print('client {} error: {}'.format(self.address,exc))
        elif self.data:
            print('client {} sent {} but then closed'.format(self.address,self.data))
        else:
            print('client {} closed socket'.format(self.address))

    def data_received(self, data):
        self.data += data
        if self.data.endswith(b'?'):
            answer = zen_utils.get_answer(self.data)
            # 将恢复传递给框架的transport.write()方法
            self.transport.write(answer)
            self.data = b''

if __name__ == "__main__":
    address = zen_utils.parse_command_line('asyncio server using callbacks')
    loop = asyncio.get_event_loop()
    coro = loop.create_server(Zenserver,*address)
    server = loop.run_until_complete(coro)
    print('listening at {}'.format(address))
    try:
        loop.run_forever()
    finally:
        server.close()
        loop.close()

```

`2.协程风格的asyncio`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'srv_asyncio_2'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'asynchronous I/O inside an asyncio coroutine.'

import asyncio
import zen_utils

@asyncio.coroutine
def handle_conversation(reader,writer):
    address = writer.get_extra_info('peername')
    print('accepted connection from {}'.format(address))
    while True:
        data = b''
        while not data.endswith(b'?'):
            more_data = yield from reader.read(4096)
            if not more_data:
                if data:
                    print('client {} sent {!r} but then closed'.format(address,data))
                else:
                    print('client {} closed socket normally'.format(address))
                return
            data += more_data
        answer = zen_utils.get_answer(data)
        writer.write(answer)

if __name__ == "__main__":
    address = zen_utils.parse_command_line('asyncio server using coroutine')
    loop = asyncio.get_event_loop()
    coro = asyncio.start_server(handle_conversation,*address)
    server = loop.run_until_complete(coro)
    print('listening at {}'.format(address))
    try:
        loop.run_forever()
    finally:
        server.close()
        loop.close()
```

`3.解决异步配置的问题`

```reStructuredText
问题：一部服务器是有硬性限制的，当CPU使用率达到100％时，异步服务器将无法为客户端提供服务。
解决方案：当需要提高性能时，首先使用异步的回调对象或协程来编写服务，并通过某个异步框架来启动服务。然后在配置一些运行服务器的操作系统，检查操作系统的CPU内核数目，有多少CPU内核，就启动多少个事件循环。根据当前的内核使用情况编写事件循环。
```

`4.小结`

```reStructuredText
第七章解决了单通信（服务器稚嫩恶搞在同一时刻与同一个客户端进行交互），而解决方案有多线程或者多进程，但是多线程或者多进程的方式会造成CPU在大多时候是空闲（只有当前正在会话的进程会占用CPU）的，CPU使用不够充分，这时候的解决方案是采用异步的方式编写服务器，通过采用select（）或者poll（）的机制手动编写异步服务器。
部署：将编写的服务安装到服务器上，并且在系统启动时运行服务器的过程。这里引入了Linux古老的inetd守护进程或者是使用supervisord这样的工具。
```

#### 章节8：缓存和消息队列

`简介`

```reStructuredText
本章研究了服务负载较重时，常用的两项基本技术：缓存和消息队列。
```

`8.1 使用Memcached（内存缓存守护进程）`

```reStructuredText
使用memcached：memacched将安装它的服务器上的空闲RAM与一个很大的近期最少使用（LRU）的缓存结合使用。
1.在每个用户空闲内存的服务器上都运行一个memcached守护进程。
2.将所有的memcached守护进程的IP地址与端口号列出，并将该列表发送给所有将要访问memcached的客户端。
3.客户端程序现在可以访问一个组织级的速度极快的键值缓存，就像是所有服务器之间共享的一个巨大的python字典。该缓存基于LRU（最近最少使用）。如果有些项长时间没有被访问，就会将这些项丢弃，为新访问的项腾出空间，并记录被频繁访问的项。
```

```python
# memcached简单的调用
# memcached default port：11211
import memcache
mc = memcache.Client(['127.0.0.1:11211'])
mc.set('user:19','simple is better than complex')
mc.get('user:19')
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'squarys'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'using memcached to cache expensive results'

import memcache,random,time,timeit

def compute_square(mc,n):
    value = mc.get('sq:%d' % n)
    if value is None:
        time.sleep(0.01)
        value = n * n
        mc.set('sq:%d' % n,value)
    return value

def main():
    mc = memcache.Client(['127.0.0.1'])
    def make_request():
        compute_square(mc,random.randint(0,5000))
    print('Ten sucessive runs:')
    for i in range(1,11):
        print('%.2fs'%timeit.timeit(make_request,number=2000),end=' ')
    print()

if __name__ == "__main__":
    main()
    pass

```

`解决脏数据的办法？`

```reStructuredText
脏数据即过时的旧数据。
解决办法：
1.memcached允许我们为缓存中的每一项设置一个过期时间，到达这个时间，memcached会负责将这些项丢弃
2.如果能够建立从信息标识到缓存中包含该表示的键的映射，那么就可以在脏数据出现后主动移除这些缓存项
3.当缓存中的记录不可用时，我们可以重写并使用新内容代替更该条记录。在应用程序首次启动时预先安装缓存对大型网站是极为重要的技术。
python装饰器可以在不改变函数调用的名称以及签名的情况下对其进行包装，实则是在python中增加缓存功能的一种方法，使用的就是基于memcached的装饰器缓存库。
```

`2020-11-2 Monday PM 19：30`

`8.2 散列与分区`

```reStructuredText
散列值：所有散列函数都有如下一个基本特性，如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“散列碰撞（collision）”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。
当客户端得到包含多个Memcached实例的列表时，会根据每个键的字符串值的散列值对memcached数据库进行分区，由计算出的散列值决定用memcached集群中的那台服务器来存储特定的记录。
```

`8.3消息队列`

```reStructuredText
消息队列保证消息的可靠性自动传输：一条消息要么完整的传输，要么完全不传输。可以设置各种的拓扑结构，应用于：
1.注册邮箱时，邮箱发送的验证邮箱消息，同时会存放于一个消息队列中，当后台服务器装备好建立一个用于发送的smtp连接时，直接从消息队列获取邮箱地址
2.可以作为自定义远程过程调用
3.经常需要将一些大容量的事件数据作为小型的线有效信息流集中存储在消息队列列中并进行分析。
而且，消息队列具有混合安排并匹配所有客户端与服务器或发布者与订阅者进程的能力，但是他们都需要连接到同一个消息队列系统。

消息队列支持的拓扑结构：
1.管道
2.发布者-订阅者
3.请求-响应
```

`在python中使用消息队列:蒙特卡洛方法计算π值`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'queuecrazy.py'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'samll application than uses serveral different message queues.'

import random,threading,time,zmq

B = 32

def ones_and_zeros(digits):
    '''
    express n in at least d binary digits,with no special prefix
    :return:
    '''
    return bin(random.getrandbits(digits)).lstrip('ob').zfill(digits)

def bitsource(zcontext,url):
    '''
    produce random points in the unit square.
    :return:
    '''
    # 创建服务端
    zsock = zcontext.socket(zmq.PUB)
    zsock.bind(url)
    while True:
        zsock.send_string(ones_and_zeros(B * 2))
        time.sleep(0.01)

def always_yes(zcontext,in_url,out_url):
    '''
    coordinates in the lower-left quadrant are inside the unit circle
    :return:
    '''
    isock = zcontext.socket(zmq.SUB)
    isock.connect(in_url)
    isock.setsockopt(zmq.SUBSCRIBE,b'00')
    osock = zcontext.socket(zmq.PUSH)
    osock.connect(out_url)
    while True:
        isock.recv_string()
        osock.send_string('Y')

def judge(zcontext,in_url,pythagoras_url,out_url):
    '''
    determine whether each input coordinate is inside the unit circle
    :return:
    '''
    isock = zcontext.socket(zmq.SUB)
    isock.connect(in_url)
    for prefix in b'01',b'10',b'11':
        isock.setsockopt(zmq.SUBSCRIBE,prefix)
    psock = zcontext.socket(zmq.REQ)
    psock.connect(pythagoras_url)
    osock = zcontext.socket(zmq.PUSH)
    osock.connect(out_url)
    unit = 2 ** (B * 2)
    while True:
        bits = isock.recv_string()
        n,m = int(bits[::2],2),int(bits[1::2],2)
        psock.send_json(n,m)
        sumsquares = psock.recv_json()
        osock.send_string('Y' if sumsquares < unit else 'N')

def pythagoras(zcontext,url):
    '''

    :return:the sum-of-quares of number sequences
    '''
    zsock = zcontext.socket(zmq.REP)
    zsock.bind(url)
    while True:
        numbers = zsock.recv_json()
        zsock.send_string(sum(n * n for n in numbers))

def tally(zcontext,url):
    '''
    how many points fall within the unit circle and return pi
    :return:return pi
    '''
    zsock = zcontext.socket(zmq.PULL)
    zsock.bind(url)
    p = q = 0
    while True:
        decision = zsock.recv_string()
        q += 1
        if decision == 'Y':
            p += 4
        print(decision,p / q)

def start_thread(function,*args):
    '''
    启动线程
    :return:
    '''
    thread = threading.Thread(target=function,args=args)
    thread.daemon = True
    thread.start()

def main(zcontext):
    pubsub = 'tcp://127.0.0.1:6700'
    reqrep = 'tcp://127.0.0.1:6701'
    pushpull = 'tcp://127.0.0.1:6702'
    start_thread(bitsource,zcontext,pubsub)
    start_thread(always_yes,zcontext,pubsub,pushpull)
    start_thread(judge,zcontext,pubsub,reqrep,pushpull)
    start_thread(pythagoras,zcontext,reqrep)
    start_thread(tally,zcontext,pushpull)
    time.sleep(30)

if __name__ == "__main__":
    main(zmq.Context())
```

`2020-11-3 周二`

```reStructuredText
zmq模块介绍（url）：

https://www.cnblogs.com/silence-cho/p/12657234.html

```

`2020-11-5 周四`

#### cheap 10：HTTP服务器

```reStructuredText
10.1:WSGI
为了解决python的HTTP服务的可移植型，通过加上一层间接地中间层来解决（WSGI）。
WSGI的调用，需要输入两个参数：
1.environ：接收一个字典，字典中提供的键值对是就是的CGI环境变量集合的扩展。
2.start_response()：通过此参数来声明响应头信息。调用后，app函数可以生成字节字符串，也可以返回一个可迭代对象。该对象可以在迭代过程中生成字节字符串。

```

```python
# ! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'wsgi_env'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'a simple http service build directly against the low-level wsgi spec'

from pprint import pformat
from wsgiref.simple_server import make_server

def app(environ,start_response):
    header = {'Content-Type':'text/plain;charset=utf-8'}
    start_response('200 ok',list(header.items()))
    yield 'Here is the wsgi environment:\r\n\r\n'.encode('utf-8')
    yield pformat(environ).encode('utf-8')

if __name__ == '__main__':
    httpd = make_server('',8000,app)
    host,port = httpd.socket.getsockname()
    print('serving on',host,'port',port)
    httpd.serve_forever()
    
```

`2020-11-6 周五`

#### New plan

```reStructuredText
rep系统 了解
Oracle数据库熟练
Linux掌握
```

#### HTTP服务的四种架构

 ```reStructuredText
1.运行python编写的服务器，使用WSGI接口运行。
2.配置mod_wsgi运行Apache，在独立的WSGIDaemonProcess中运行python服务器代码
3.后端运行python编写的服务器，前端运行能返回静态文件，又对python编写的动态资源进行反向代理web服务器。
4.最前端运行一个纯粹的反向代理（Varnish），在反向代理后端运行Apache或Nginx，在最后端进行python编写的HTTP服务器。
 ```

#### 2020-11-7 Saturday 10.7节：不使用web框架编写WSGI可调用的对象

A 构建方法：1.查看WSGI的使用说明，了解环境变量字典的属性 2.使用WebOb、Werkzeug工具提供的包装函数。

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'timeapp_raw'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'a simple http service built directly against the low-level wsgi spec.'

import time

def app(environ,start_response):
    host = environ.get('HTTP_HOST','127.0.0.1')
    path = environ.get('PATH_INFO','/')
    if ':' in host:
        host,port = host.split(':',1)
    if '?' in path:
        path,query = path.split('?',1)
    headers = [('Content-Type','text/plain;charset=utf-8')]
    if environ['REQUEST_METHOD'] != 'GET':
        start_response('501 Not Implemented',headers)
        yield b'501 Not Implemented'
    elif host != '127.0.0.1' or path != '/':
        start_response('404 Not Found',headers)
        yield b'404 Not Found'
    else:
        start_response('200 ok',headers)
        yield time.ctime().encode('ascii')
    
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'timeapp_webob'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'a wsgi callable built using webob'

import time,webob

def app(environ,start_response):
    request = webob.Request(environ)
    if environ['REQUEST_METHOD'] != 'GET':
        response = webob.Response('501 Not Implemented',status=501)
    elif request.domain != '127.0.0.1' or request.path != '/':
        response = webob.Response('404 Not Found',status=404)
    else:
        response = webob.Response(time.ctime())
    return response(environ,start_response)

```

```reStructuredText
webob使用补充：
1.webob内部实现了两个模式：A.从可能包含端口号的Host头中单独分离出主机名 B.忽略路径结尾的查询字符串
2.webob提供了一个Response对象，该对象设置了所有关于内容类型以及编码的信息，因此只需要传入一个字符串作为响应体，由webob自动处理。
3.webob的response类提供了content_type和charset两个独立属性，允许用户将将Content_Type头信息的两部分看做两个独立的值进行处理。
```



```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'timeapp_werkz'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'a wsgi callable built using werkzeug'

import time
from werkzeug.wrappers import Response,Request

@Request.application
def app(request):
    host = request.host
    if ':' in host:
        host,port = host.split(':',1)
    if request.method != 'GET':
        return Response('501 Not Implemented',status = 501)
    elif host != '127.0.0.1' or request.path != '/':
        return Response('404 Not Found',status = 404)
    else:
        return Response(time.ctime())
```

#### 2020-11-11 Wednesday 第十二章：电子邮件的构造与解析

#####  12.1电子邮件的消息格式

```reStructuredText
1.电子邮件以原始ASCII文本的形式表示，使用1-127的字符代码
2.行位标记由回车加换行两个连续的字符组成
3.电子邮件包含一个邮件箭头、一个空行和邮件体
4.邮件头有不区分大小写的属性名、冒号一级属性值组成；邮件头可以有多行，但是除了第一行外都必须使用空格进行缩进。
5.纯文本中不支持Unicode字符和二进制数据，所以其他标准提供的编码方式支持将更丰富的数据格式添加到原始ASCII文本找那个，并进行传输和存储。
```

`电子邮件格式：`

```reStructuredText
To: recipient@example.com
From: Test Sender <sender@example.com>
Subject: Test Message, Chapter 12
Date: Tue, 25 Mar 2014 19:20:08 -0400
Message-ID: <20140325232008.15748.50494@guinness>
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
MIME-Version: 1.0

Hello,
This is a basic message from Chapter 12.
 - Anonymous
```

```reStructuredText
From:之处电子邮件消息的作者，From支持真实地人名，也支持包含在尖括号中的作者的电子邮件地址
Reply-to：指出位列在From头里的作者地址
To：列出一个或多个主接受者
Cc：列出一个或多个应该受到电子邮件‘抄送’的接受者，这些接受者并不是邮件的柱接受人
Bcc：列出应该受到电子邮件‘秘密抄送’的接受者，其他接受者都不知道Bcc列出的接受者也会收到邮件
Subject：消息内容的概述，由作者编写
Date：指定消息发送或接受的时间
Message-Id:唯一标识电子邮件的字符串
In-Reply-To：整个邮件对话中Message-Idweiyi标识的邮件之前的邮件。
Received：是电子邮件每次到达SMTP传输过程中的一跳时添加，电子邮件服务器管理员同科通过仔细阅读Teceived路径来确定消息是否传达正确
```

`构造电子邮件消息：`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'build_basic_email'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'a simple basic email build'

import email.message,email.policy,email.utils,sys

text = "Hello," \
       "this is a basic message from chapter 12." \
       "- JZ"

def main():
    message = email.message.EmailMessage(email.policy.SMTP)
    message['To'] = 'jing1053578154@163.com'
    message['From'] = 'JZ <1053578154@qq.com>'
    message['Subject'] = 'Test message,chapter 12'
    message['Date'] = email.utils.formatdate(localtime = True)
    message['Message-ID'] = email.utils.make_msgid()
    message.set_content(text)
    # 将字节写入文本文件
    sys.stdout.buffer.write(message.as_bytes())

if __name__ == '__main__':
    main()
```

```reStructuredText
D:\python\课件包\网络编程\网络编程代码\program_chapter_7_20201027\venv\Scripts\python.exe D:/python/课件包/网络编程/网络编程代码/program_chapter_7_20201027/program_12/program_12_2/build_basic_email.py
To: jing1053578154@163.com
From: JZ <1053578154@qq.com>
Subject: Test message,chapter 12
Date: Wed, 11 Nov 2020 16:29:57 +0800
Message-ID: <160508339793.14680.6692342519831624548@LAPTOP-D1ALKSAK>
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
MIME-Version: 1.0

Hello,this is a basic message from chapter 12.- JZ

Process finished with exit code 0

```

##### 12.3添加多媒体和HTML

```reStructuredText
1.使用带有链接的文字叫超文本；带有图片、视频、声音的内容叫多媒体。
2.MIME标准为非ASCII数据提供的通用且可扩展的方案：我们可以在Content-Type邮件头中指定一个便捷字符串，使用便捷字符串将电子邮件消息分为多个部件，每个子部件都有自己的邮件头，指定自己的内容类型和编码。
3.构造MIME消息：a.动用set_content()设置主消息体 b.调用add_related()零次或多次。 c.调用add_alternative()零次或多次 d.调用add_attachment()零次或多次
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'build_mine_email'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'mine path'

import argparse, email.message, email.policy, email.utils, mimetypes, sys

plain = """Hello,
This is a MIME message from Chapter 12.
- Anonymous"""

html = """<p>Hello,</p>
<p>This is a <b>test message</b> from Chapter 12.</p>
<p>- <i>Anonymous</i></p>"""

img = """<p>This is the smallest possible blue GIF:</p>
<img src="cid:{}" height="80" width="80">"""

# Tiny example GIF from http://www.perlmonks.org/?node_id=7974
blue_dot = (b'GIF89a1010\x900000\xff000,000010100\x02\x02\x0410;'
            .replace(b'0', b'\x00').replace(b'1', b'\x01'))

def main(args):
    message = email.message.EmailMessage(email.policy.SMTP)
    message['To'] = 'Test Recipient <recipient@example.com>'
    message['From'] = 'Test Sender <sender@example.com>'
    message['Subject'] = 'Foundations of Python Network Programming'
    message['Date'] = email.utils.formatdate(localtime=True)
    message['Message-ID'] = email.utils.make_msgid()

    if not args.i:
        message.set_content(html, subtype='html')
        message.add_alternative(plain)
    else:
        cid = email.utils.make_msgid()  # RFC 2392: must be globally unique!
        message.set_content(html + img.format(cid.strip('<>')), subtype='html')
        message.add_related(blue_dot, 'image', 'gif', cid=cid,
                            filename='blue-dot.gif')
        message.add_alternative(plain)

    for filename in args.filename:
        mime_type, encoding = mimetypes.guess_type(filename)
        if encoding or (mime_type is None):
            mime_type = 'application/octet-stream'
        main, sub = mime_type.split('/')
        if main == 'text':
            with open(filename, encoding='utf-8') as f:
                text = f.read()
            message.add_attachment(text, sub, filename=filename)
        else:
            with open(filename, 'rb') as f:
                data = f.read()
            message.add_attachment(data, main, sub, filename=filename)

    sys.stdout.buffer.write(message.as_bytes())

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Build, print a MIME email')
    parser.add_argument('-i', action='store_true', help='Include GIF image')
    parser.add_argument('filename', nargs='*', help='Attachment filename')
    main(parser.parse_args())
```

```bash
python3 build_mine_email.py
python3 build_mine_email.py attachment.txt arrachment.gz
python3 build_mine_email.py -i
python3 build_mine_email.py -i attachment.txt attachment.gz
```

```reStructuredText
multipart/alternative是所有multipart/*内容类型的一种，这种类型的邮件消息都是用边界字符串对MIME边界字符串对MIME邮件进行分割，其作用是传输多条消息的多个版本，每个版本都显示完整的消息。
multipart段的规则：
1.如果至少调用了一次add_related()那么就会生成一个multipart/related段，其中包含set_content()指定的邮件体与所有相关内容
2.如果至少调用了一次add_alternative()，那么就会生成一个multipart/alternative段，其中包含原始邮件体以及添加的其他版本的邮件体
3.如果至少调用了一次add_attachment()，就会在外层生成一个multipart/mixed段，其中包含添加的所有附件
```

##### 12.4 添加内容

```reStructuredText
...

(...,cte='quoted-printable')方法：所有内容添加方法都会选择ASCII或Base64中的一种默认的内容传输编码方式。七位信息安全地表示电子邮件中的文本，将会选择ASCII文本，否则就会使用Base64编码。

...
```

#### 2020-11-16 Monday chapter 12.5：解析电子邮件消息

通过email模块解析电子邮件消息后，进行读取邮件消息。

`A.使用EmailMessage读取邮件体和附件：`

```python

```

`B.遍历MIME部件：`

```reStructuredText
*遍历MIME电子邮件的四个准则*
1.
2.
3.
4.
```

```python

```

`C.使用国际化支持的电子邮件，进行邮件头编码：`

```python

```

`D.解析日期函数：formatdate()生成符合标准的日期：`

```bash

```

#### chapter 13 : SMTP（邮件传输协议 Simple Mail Transport Protocol）

`A.SMTP作用：`

```reStructuredText
1.将用户输入的点字邮件提交至服务器 ，再由该服务器负责将电子邮件发送至接收服务器。
2.点字邮件服务器使用SMTP来传输消息。每条消息都会经过互联网的多态邮件服务器，直接到达负责接受的点字邮件地址域（domain，@字符后的地址）
...
默认端口53
python库：smtplib
```

`B.SMTP与WEB邮件服务的演变：`

```reStructuredText
早期的邮件服务器必须通过互联网连接到一个已经保存了连接到的邮件的服务器，然后进行电子邮件的下载工作。其整个连接到传输下载的过程相当具有风险性：可能会遭遇连接失败、发送或接受下载机器的关机、断网场景，或者是服务器的塌机，因此需要某种方法将编写完成的点字邮件提交至提供不间断服务的邮件服务器，在该服务器的发送队列中，等待发送。
电子邮件提交：邮件提交过程中通常遇到防止垃圾邮件的问题，大多数的ISP会进制向电脑的25端口发起TCP连接，点字邮件通常会提交587端口。为了防止垃圾邮件发送者连接到用户的ISP并伪装成用户发送信息，点字邮件客户端会使用认证的SMTP。
ISP：Internet服务器供应商，ISP是Internet的接入入口。作用1.为用户提供Internet接入服务2.为用户提供邮件、信息发布代理服务
Web邮件到来：浏览器与某个web API进行交互，另一端大型机构通过原始的SMTP连接接收或发送电子邮件。
SMTP的基础知识：
1.SMTP是基于TCP/IP的协议
2.可以对连接进行认证，也可以不认证
3.可以对连接进行加密，也可以不加密
SMTP协议并不通过Cc、Bcc的地址头来决定电子邮件的目标地址。

```

`C.SMTP库`

```reStructuredText
模块名：smtplib
参数：SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'simple_13_1'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'使用smtplib.sendmail()发送电子邮件'

import sys,smtplib

message_template = 'To:{} ' \
          'From:{} ' \
          'subject:Test Message from simple.py' \
          'Hello' \
          'this is a test message sent to you from the simple.py program in foundations of python network programing.'

def main():
    if len(sys.argv) < 4:
        name = sys.argv[0]
        print('usage:{} server fromaddr toaddr [toaddr]'.format(name))
        sys.exit(2)

    # SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
    server,fromaddr,toaddrs = sys.argv[1],sys.argv[2],sys.argv[3]
    message = message_template.format(','.join(toaddrs),fromaddr)
    connection = smtplib.SMTP(server)
    connection.sendmail(fromaddr,toaddrs,message)
    connection.quit()

    s = '' if len(toaddrs) == 1 else 's'
    print('Message sent to {} recipient {}'.format(len(toaddrs),s))

if __name__ == '__main__':
    main()
```

`D.错误处理、绘画调试`

```rest
查询地址信息时发生错误：socket.gaierror
一般的网络和通信问题：socket.error
其他地址异常错误：socket.herror
SMTP会话问题：smtplib.SMTPException或它的一个子类

SMTP的调试代码：connection.set_debuglevel(1)
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'debug_13_2'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'debug 调试'

import sys,smtplib,socket

message_template = 'To:{} ' \
          'From:{} ' \
          'subject:Test Message from simple.py' \
          'Hello' \
          'this is a test message sent to you from the simple.py program in foundations of python network programing.'

def main():
    if len(sys.argv) < 4:
        name = sys.argv[0]
        print('usage:{} server fromaddr toaddr [toaddr]'.format(name))
        sys.exit(2)

    # SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
    server,fromaddr,toaddrs = sys.argv[1],sys.argv[2],sys.argv[3]
    message = message_template.format(','.join(toaddrs),fromaddr)

    try:
        connection = smtplib.SMTP(server)
        connection.set_debuglevel(1)
        connection.sendmail(fromaddr,toaddrs,message)
    except (socket.gaierror,socket.error,socket.herror,smtplib.SMTPException) as e:
        print('your message may not have been sent')
        print(e)
        sys.exit(1)
    else:
        s = '' if len(toaddrs) == 1 else 's'
        print('Message sent to {} recipient {}'.format(len(toaddrs),s))
        connection.quit()

if __name__ == '__main__':
    main()
    
```

```reStructuredText
在会话的过程中，客户端smtplib库会发送一个EHLO命令与SMTP进行会话
```



`E.从EHLO获取信息`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'ehlo_13_4'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'消息大小限制'

import sys,smtplib,socket

message_template = 'To:{} ' \
          'From:{} ' \
          'subject:Test Message from simple.py' \
          'Hello' \
          'this is a test message sent to you from the simple.py program in foundations of python network programing.'

def main():
    if len(sys.argv) < 4:
        name = sys.argv[0]
        print('usage:{} server fromaddr toaddr [toaddr]'.format(name))
        sys.exit(2)

    # SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
    server,fromaddr,toaddrs = sys.argv[1],sys.argv[2],sys.argv[3]
    message = message_template.format(','.join(toaddrs),fromaddr)

    try:
        connection = smtplib.SMTP(server)
        connection.set_debuglevel(1)
        report_on_message_size(connection,fromaddr,toaddrs,message)
    except (socket.gaierror,socket.error,socket.herror,smtplib.SMTPException) as e:
        print('your message may not have been sent')
        print(e)
        sys.exit(1)
    else:
        s = '' if len(toaddrs) == 1 else 's'
        print('Message sent to {} recipient {}'.format(len(toaddrs),s))
        connection.quit()

def report_on_message_size(connection,fromaddr,toaddrs,message):
    # 获取邮件信息
    code = connection.ehlo()[0]
    uses_esmtp = (200 <= code <= 299)
    if not uses_esmtp:
        code = connection.helo()[0]
        if not (200 <= code <=299):
            print('remote server fefused helo;code:',code)
            sys.exit(1)
    # 检查是否存在starttls
    if uses_esmtp and connection.has_extn('size'):
        print('Maximum message size is',connection.esmtp_features['size'])
        if len(message) > int(connection.esmtp_features['size']):
            print('message too large;aborting')
            sys.exit(1)

    connection.sendmail(fromaddr,toaddrs,message)

if __name__ == '__main__':
    main()
```

`F.使用安全套接层和传输层安全协议SSL、TLS`

```reStructuredText
SMTP中使用TLS的步骤：
1.创建SMTP对象
2.发送EHLO命令，如果远程服务器不支持EHLO，同样不支持TLS
3.检查s.has_extn()，查看是否存在starttls。如果不存在，表示远程服务器不支持TLS，只能使用明文发送消息
4.构造SSL上下文对象，验证服务器身份
5.调用starttls()，初始化加密通道
6.再次调用ehlo()，此时已经加密
7.发送消息
```

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'tls_13_5'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'使用TLS进行进行安全连接'

import sys,smtplib,socket,ssl

message_template = 'To:{} ' \
          'From:{} ' \
          'subject:Test Message from simple.py' \
          'Hello' \
          'this is a test message sent to you from the simple.py program in foundations of python network programing.'

def main():
    if len(sys.argv) < 4:
        name = sys.argv[0]
        print('usage:{} server fromaddr toaddr [toaddr]'.format(name))
        sys.exit(2)

    # SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
    server,fromaddr,toaddrs = sys.argv[1],sys.argv[2],sys.argv[3]
    message = message_template.format(','.join(toaddrs),fromaddr)

    try:
        connection = smtplib.SMTP(server)
        connection.set_debuglevel(1)
        send_message_securely(connection,fromaddr,toaddrs,message)
    except (socket.gaierror,socket.error,socket.herror,smtplib.SMTPException) as e:
        print('your message may not have been sent')
        print(e)
        sys.exit(1)
    else:
        s = '' if len(toaddrs) == 1 else 's'
        print('Message sent to {} recipient {}'.format(len(toaddrs),s))
        connection.quit()

def send_message_securely(connection,fromaddr,toaddrs,message):
    # 发送ehlo命令
    code = connection.ehlo()[0]
    uses_esmtp = (200 <= code <= 299)
    if not uses_esmtp:
        code = connection.ehlo()[0]
        if not (200 <= code <=299):
            print('remote server fefused helo;code:', code)
            sys.exit(1)

    if uses_esmtp and connection.has_extn('starttls'):
        print('negotiating tls...')
        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        context.set_default_verify_paths()
        context.verify_mode = ssl.CERT_REQUIRED
        connection.starttls(context=context)
        code = connection.ehlo()[0]
        if not (200 <= code <= 299):
            print("couldn't ehlo after starttls")
            sys.exit(5)
        print('using tls connection')
    else:
        print('server does not support tls; using normal connection')
        
    connection.sendmail(fromaddr,toaddrs,message)

if __name__ == '__main__':
    main()
```

`G.认证的SMTP`

```python
#! /usr/bin/python3
# ! _*_ coding:utf-8 _*_
# program_name:'login_13_6'
# version:'Ubuntu linux'
# packages_url:''
# author:'jingzuo'
# program_url:''
# program_description:'认证smtp'

import sys,smtplib,socket
from getpass import getpass

message_template = 'To:{} ' \
          'From:{} ' \
          'subject:Test Message from simple.py' \
          'Hello' \
          'this is a test message sent to you from the simple.py program in foundations of python network programing.'

def main():
    if len(sys.argv) < 4:
        name = sys.argv[0]
        print('usage:{} server fromaddr toaddr [toaddr]'.format(name))
        sys.exit(2)

    # SMTP的服务器名称，发送者的地址，一个或多个接受者的地址
    server,fromaddr,toaddrs = sys.argv[1],sys.argv[2],sys.argv[3]
    message = message_template.format(','.join(toaddrs),fromaddr)
    username = input('enter name:')
    password = getpass('enter password:')

    try:
        connection = smtplib.SMTP(server)
        try:
            connection.login(username,password)
        except smtplib.SMTPException as e:
            print('authentication failed:',e)
            sys.exit(1)
        connection.set_debuglevel(1)
        connection.sendmail(fromaddr,toaddrs,message)
    except (socket.gaierror,socket.error,socket.herror,smtplib.SMTPException) as e:
        print('your message may not have been sent')
        print(e)
        sys.exit(1)
    else:
        s = '' if len(toaddrs) == 1 else 's'
        print('Message sent to {} recipient {}'.format(len(toaddrs),s))
        connection.quit()

if __name__ == '__main__':
    main()
```

#### 2020-11-18 Wednesday chapter16：Telnet and ssh

`A.Words`

```reStructuredText
1.probe v.探测，探索 n.探针，探测器
eg:He hold the a device to probe for the location of the gold.
2.hunter n.猎人，搜寻者
eg:The man with a hound is an expricenced hunter.
3.governor n.州长，主管，负责人
eg:This famous actor used to be the governor of califonia.
4.bow v.鞠躬，弯腰 n.弓
eg:The singer bowed to us after the show.
5.scrape n.檫伤 v.刮，檫
eg:She is treating the scrape on the child's knee.
```

#### 2020-11-20 Friday 

`A.words`

```reStructuredText
1.inviting adj.诱人的；引人入胜的
eg:This bone looks rather inviting to the dog.
2.herd n.兽群，牧群 v.放牧，群集
eg:look! There is a herd of sheep.
```

`B.16.1:命令行自动化工具`

```reStructuredText
1.Fabric 支持python2
2.Ansible 
3.SaltStack 
4.pexpect
```

`C.命令扩展与引用`

```bash
# 展示所有匹配文件
echo *
# 转义符号
echo \*
# 统计
echo wc -w < xxx.txt 
echo wc -l < xxx.txt
```

subprocess

```python
# python中调用命令行的方式
import subprocess
args = ['echo','xxx','*','xxxx']
subprocess.call(args)
```

